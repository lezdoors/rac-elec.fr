import { pgTable, unique, serial, text, boolean, timestamp, integer, numeric, uuid, jsonb } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"



export const serviceRequests = pgTable("service_requests", {
	id: serial().primaryKey().notNull(),
	referenceNumber: text("reference_number").notNull(),
	clientType: text("client_type").notNull(),
	name: text().notNull(),
	email: text().notNull(),
	phone: text().notNull(),
	company: text(),
	siret: text(),
	serviceType: text("service_type").notNull(),
	requestType: text("request_type").notNull(),
	buildingType: text("building_type").notNull(),
	projectStatus: text("project_status").notNull(),
	permitNumber: text("permit_number"),
	permitDeliveryDate: text("permit_delivery_date"),
	address: text().notNull(),
	addressComplement: text("address_complement"),
	city: text().notNull(),
	postalCode: text("postal_code").notNull(),
	cadastralReference: text("cadastral_reference"),
	powerRequired: text("power_required").notNull(),
	phaseType: text("phase_type"),
	desiredCompletionDate: text("desired_completion_date"),
	billingAddress: text("billing_address"),
	billingCity: text("billing_city"),
	billingPostalCode: text("billing_postal_code"),
	hasArchitect: boolean("has_architect"),
	architectName: text("architect_name"),
	architectPhone: text("architect_phone"),
	architectEmail: text("architect_email"),
	comments: text(),
	estimatedPrice: text("estimated_price"),
	status: text().default('new').notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow().notNull(),
	category: text(),
	priceEstimate: text("price_estimate"),
	aiAnalysis: text("ai_analysis"),
	customerResponse: text("customer_response"),
	assignedTo: integer("assigned_to"),
	assignedAt: timestamp("assigned_at", { mode: 'string' }),
	validatedBy: integer("validated_by"),
	validatedAt: timestamp("validated_at", { mode: 'string' }),
	scheduledDate: timestamp("scheduled_date", { mode: 'string' }),
	scheduledTime: text("scheduled_time"),
	enedisReferenceNumber: text("enedis_reference_number"),
	notes: text(),
	completedAt: timestamp("completed_at", { mode: 'string' }),
	cancellationReason: text("cancellation_reason"),
	lastUpdatedBy: integer("last_updated_by"),
	otherRequestTypeDesc: text("other_request_type_desc"),
	terrainViabilise: text("terrain_viabilise"),
	paymentStatus: text("payment_status"),
	paymentId: text("payment_id"),
	paymentAmount: numeric("payment_amount", { precision: 10, scale:  2 }),
	paymentMethod: text("payment_method"),
	paymentDate: timestamp("payment_date", { mode: 'string' }),
	ipAddress: text("ip_address"),
	userAgent: text("user_agent"),
	cardBrand: text("card_brand"),
	cardLast4: text("card_last4"),
	cardExpMonth: integer("card_exp_month"),
	cardExpYear: integer("card_exp_year"),
	billingName: text("billing_name"),
	bankName: text("bank_name"),
	paymentError: text("payment_error"),
}, (table) => [
	unique("service_requests_reference_number_unique").on(table.referenceNumber),
]);

export const activityLogs = pgTable("activity_logs", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	action: text().notNull(),
	entityType: text("entity_type").notNull(),
	entityId: integer("entity_id").notNull(),
	details: text(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	ipAddress: text("ip_address"),
});

export const emailTemplates = pgTable("email_templates", {
	id: serial().primaryKey().notNull(),
	templateKey: text("template_key").notNull(),
	name: text().notNull(),
	subject: text().notNull(),
	htmlContent: text("html_content").notNull(),
	textContent: text("text_content").notNull(),
	description: text(),
	variables: text(),
	active: boolean().default(true).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow().notNull(),
	updatedBy: integer("updated_by"),
}, (table) => [
	unique("email_templates_template_key_unique").on(table.templateKey),
]);

export const systemConfigs = pgTable("system_configs", {
	id: serial().primaryKey().notNull(),
	configKey: text("config_key").notNull(),
	configValue: text("config_value"),
	configGroup: text("config_group").notNull(),
	isSecret: boolean("is_secret").default(false).notNull(),
	description: text(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow().notNull(),
	updatedBy: integer("updated_by"),
}, (table) => [
	unique("system_configs_config_key_unique").on(table.configKey),
]);

export const leads = pgTable("leads", {
	id: serial().primaryKey().notNull(),
	sessionToken: uuid("session_token").defaultRandom().notNull(),
	firstName: text("first_name"),
	lastName: text("last_name"),
	email: text(),
	phone: text(),
	clientType: text("client_type"),
	company: text(),
	siret: text(),
	serviceType: text("service_type").default('electricity'),
	requestType: text("request_type"),
	otherRequestTypeDesc: text("other_request_type_desc"),
	buildingType: text("building_type"),
	terrainViabilise: text("terrain_viabilise"),
	projectStatus: text("project_status"),
	permitNumber: text("permit_number"),
	permitDeliveryDate: text("permit_delivery_date"),
	address: text(),
	addressComplement: text("address_complement"),
	city: text(),
	postalCode: text("postal_code"),
	cadastralReference: text("cadastral_reference"),
	powerRequired: text("power_required"),
	phaseType: text("phase_type"),
	desiredCompletionDate: text("desired_completion_date"),
	billingAddress: text("billing_address"),
	billingCity: text("billing_city"),
	billingPostalCode: text("billing_postal_code"),
	hasArchitect: boolean("has_architect"),
	architectName: text("architect_name"),
	architectPhone: text("architect_phone"),
	architectEmail: text("architect_email"),
	comments: text(),
	vatRate: text("vat_rate"),
	termsAccepted: boolean("terms_accepted").default(false),
	immediatePurchaseAccepted: boolean("immediate_purchase_accepted").default(false),
	connectionDelay: text("connection_delay"),
	completedSteps: integer("completed_steps").default(0),
	isCompleted: boolean("is_completed").default(false),
	convertedToRequest: boolean("converted_to_request").default(false),
	convertedRequestId: integer("converted_request_id"),
	assignedTo: integer("assigned_to"),
	ipAddress: text("ip_address"),
	userAgent: text("user_agent"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow().notNull(),
	lastTouchedAt: timestamp("last_touched_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	unique("leads_session_token_unique").on(table.sessionToken),
]);

export const uiAnimations = pgTable("ui_animations", {
	id: serial().primaryKey().notNull(),
	name: text().notNull(),
	type: text().notNull(),
	category: text().notNull(),
	component: text().notNull(),
	enabled: boolean().default(true).notNull(),
	default: boolean().default(false).notNull(),
	config: jsonb().default({}).notNull(),
	pages: text().array(),
	lastModifiedAt: timestamp("last_modified_at", { mode: 'string' }).defaultNow().notNull(),
	lastModifiedBy: integer("last_modified_by"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
});

export const users = pgTable("users", {
	id: serial().primaryKey().notNull(),
	username: text().notNull(),
	password: text().notNull(),
	fullName: text("full_name").default(').notNull(),
	email: text().default('admin@example.com').notNull(),
	role: text().default('agent').notNull(),
	active: boolean().default(true).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	createdBy: integer("created_by"),
	permissions: jsonb(),
	lastLogin: timestamp("last_login", { mode: 'string' }),
	smtpHost: text("smtp_host"),
	smtpPort: integer("smtp_port"),
	smtpSecure: boolean("smtp_secure").default(true),
	smtpUser: text("smtp_user"),
	smtpPassword: text("smtp_password"),
	smtpFromEmail: text("smtp_from_email"),
	smtpEnabled: boolean("smtp_enabled").default(false),
	commissionEnabled: boolean("commission_enabled").default(true),
	commissionRate: numeric("commission_rate").default('14'),
	onboardingCompleted: boolean("onboarding_completed").default(false),
}, (table) => [
	unique("users_username_unique").on(table.username),
]);
